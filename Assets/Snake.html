<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake Small Map</title>
  <style>
    :root{
      --tile1:#07172a;
      --tile2:#0b2032;
      --snake:#4ade80;
      --food:#fb7185;
      --text:#e6eef8;
      --wall:#0f1724;
    }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(180deg,#04101b,#071029);color:var(--text)}
    .wrap{min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:20px}
    h2{margin:0 0 6px 0}
    .hud{display:flex;gap:12px;align-items:center}
    button{background:#111827;color:var(--text);border:1px solid rgba(255,255,255,.06);padding:8px 12px;border-radius:6px;cursor:pointer}
    canvas{background:transparent;border-radius:8px;box-shadow:0 8px 30px rgba(2,6,23,.6)}
    .info{font-size:14px}
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Snake</h2>
    <div class="hud">
      <div class="info">Score: <span id="score">0</span></div>
      <button id="startBtn">Start / Restart</button>
      <div class="info">Arrow keys or WASD</div>
    </div>
    <canvas id="board" width="320" height="320"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const scoreEl = document.getElementById('score');

    // --- CONFIGURATION (change these to resize)
    const gridSize = 16;      // **smaller map**: 16x16 cells
    const cell = canvas.width / gridSize;
    const tickMs = 120;      // game speed: lower = faster

    let snake, dir, food, score, running, tickInterval;

    function reset() {
      const mid = Math.floor(gridSize / 2);
      snake = [{x:mid,y:mid},{x:mid-1,y:mid},{x:mid-2,y:mid}];
      dir = {x:1,y:0};
      placeFood();
      score = 0;
      scoreEl.textContent = score;
      running = false;
      clearInterval(tickInterval);
      draw();
    }

    function placeFood() {
      food = {
        x: Math.floor(Math.random()*gridSize),
        y: Math.floor(Math.random()*gridSize)
      };
      if (snake.some(s => s.x===food.x && s.y===food.y)) placeFood();
    }

    function start() {
      if (running) return;
      running = true;
      tickInterval = setInterval(tick, tickMs);
    }

    function tick() {
      const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

      // wall collision (no wrap)
      if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
        gameOver();
        return;
      }

      if (snake.some(s => s.x===head.x && s.y===head.y)) {
        gameOver();
        return;
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score += 1;
        scoreEl.textContent = score;
        placeFood();
      } else {
        snake.pop();
      }

      draw();
    }

    function gameOver() {
      clearInterval(tickInterval);
      running = false;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '16px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over â€” Click Start to play again', canvas.width/2, canvas.height/2);
    }

    function drawGrid() {
      for (let y=0;y<gridSize;y++){
        for (let x=0;x<gridSize;x++){
          const isAlt = (x + y) % 2 === 0;
          ctx.fillStyle = isAlt ? getComputedStyle(document.documentElement).getPropertyValue('--tile1').trim() : getComputedStyle(document.documentElement).getPropertyValue('--tile2').trim();
          ctx.fillRect(x*cell, y*cell, cell, cell);
        }
      }
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall').trim();
      ctx.lineWidth = 4;
      ctx.strokeRect(0,0,canvas.width,canvas.height);
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawGrid();

      // food
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--food').trim();
      const pad = Math.max(2, cell * 0.12);
      ctx.fillRect(food.x*cell + pad, food.y*cell + pad, cell - pad*2, cell - pad*2);

      // snake
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--snake').trim();
      for (let i=0;i<snake.length;i++){
        const s = snake[i];
        if (i === 0) {
          ctx.fillStyle = shadeColor(getComputedStyle(document.documentElement).getPropertyValue('--snake').trim(), 18);
          ctx.fillRect(s.x*cell + 1, s.y*cell + 1, cell - 2, cell - 2);
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--snake').trim();
        } else {
          ctx.fillRect(s.x*cell + 1, s.y*cell + 1, cell - 2, cell - 2);
        }
      }
    }

    function shadeColor(hex, percent) {
      const h = hex.replace('#','');
      const r = parseInt(h.substring(0,2),16);
      const g = parseInt(h.substring(2,4),16);
      const b = parseInt(h.substring(4,6),16);
      const newR = Math.min(255, Math.floor(r + (255 - r) * (percent/100)));
      const newG = Math.min(255, Math.floor(g + (255 - g) * (percent/100)));
      const newB = Math.min(255, Math.floor(b + (255 - b) * (percent/100)));
      return '#' + newR.toString(16).padStart(2,'0') + newG.toString(16).padStart(2,'0') + newB.toString(16).padStart(2,'0');
    }

    window.addEventListener('keydown', e => {
      const key = e.key;
      const mapping = {
        ArrowUp: {x:0,y:-1}, w:{x:0,y:-1}, W:{x:0,y:-1},
        ArrowDown:{x:0,y:1}, s:{x:0,y:1}, S:{x:0,y:1},
        ArrowLeft:{x:-1,y:0}, a:{x:-1,y:0}, A:{x:-1,y:0},
        ArrowRight:{x:1,y:0}, d:{x:1,y:0}, D:{x:1,y:0}
      };
      const nd = mapping[key];
      if (!nd) return;
      if (snake.length>1 && nd.x === -dir.x && nd.y === -dir.y) return;
      dir = nd;
      if (!running) start();
    });

    startBtn.addEventListener('click', () => {
      reset();
      start();
    });

    reset();
  </script>
</body>
</html>
