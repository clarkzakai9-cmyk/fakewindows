<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Chunked Video Library — Object URL Playback</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#0f0f0f;--card:#1e1e1e;--accent:#ff4b2b;--muted:#999}
  body{font-family:Segoe UI,Roboto,system-ui;background:var(--bg);color:#fff;margin:0;padding:2rem;text-align:center}
  #controls{display:flex;gap:.75rem;justify-content:center;flex-wrap:wrap;margin-bottom:1rem}
  input[type=file]{padding:.5rem;border-radius:8px;background:#111;color:#fff;border:1px solid #222}
  button{background:var(--accent);color:#fff;border:none;padding:.5rem .9rem;border-radius:8px;cursor:pointer;font-weight:600}
  #dropZone{border:2px dashed var(--accent);padding:1rem;border-radius:10px;margin:.75rem auto;max-width:900px;color:var(--accent);background:#0b0b0b;display:none}
  #gallery{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:1rem;max-width:1200px;margin:1rem auto 0}
  .card{background:var(--card);padding:1rem;border-radius:12px;text-align:left;box-shadow:0 2px 8px rgba(0,0,0,.6)}
  .card h3{margin:0 0 .5rem 0;font-size:1rem;color:#fff}
  .meta{font-size:.85rem;color:var(--muted);margin-top:.5rem;display:flex;justify-content:space-between;align-items:center;gap:.5rem}
  .small-btn{background:#333;padding:.35rem .6rem;border-radius:8px;font-size:.85rem;color:#fff;border:none;cursor:pointer}
  #playerModal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.7);align-items:center;justify-content:center;z-index:999}
  #playerBox{background:#111;padding:1rem;border-radius:10px;width:90%;max-width:900px}
  #playerBox video{width:100%;height:auto;background:#000;border-radius:8px}
  #status{color:var(--muted);margin-top:.5rem;font-size:.9rem}
  .progress-wrap{width:100%;background:#0b0b0b;border-radius:8px;overflow:hidden;margin-top:.5rem}
  .progress-bar{height:10px;background:linear-gradient(90deg,var(--accent),#ff7a5a);width:0%;transition:width 200ms linear}
  .small-muted{color:var(--muted);font-size:.85rem}
</style>
</head>
<body>
  <h1>Chunked Video Library</h1>

  <div id="controls">
    <input id="fileInput" type="file" accept="video/*" multiple />
    <button id="toggleDrop">Toggle Drop Area</button>
    <button id="clearAll">Clear All Stored Videos</button>
  </div>

  <div id="dropZone">Drop video files here or use the file input above.</div>

  <div id="gallery" aria-live="polite"></div>

  <div id="playerModal">
    <div id="playerBox">
      <button id="closePlayer" style="float:right;background:#222;color:#fff;border:none;padding:.4rem .6rem;border-radius:6px;cursor:pointer">Close</button>
      <h3 id="playerTitle" style="margin-top:0;color:#fff"></h3>
      <video id="player" controls></video>
      <div id="status"></div>
    </div>
  </div>

<script>
/* CONFIG */
const CHUNK_SIZE = 64 * 1024 * 1024; // 64 MB per chunk
const DB_NAME = "chunkedVideoDB";
const DB_VERSION = 1;
const FILE_STORE = "files";
const CHUNK_STORE = "chunks";

/* IndexedDB helpers */
let db;
function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains(FILE_STORE)) d.createObjectStore(FILE_STORE, { keyPath: "id", autoIncrement: true });
      if (!d.objectStoreNames.contains(CHUNK_STORE)) {
        const cs = d.createObjectStore(CHUNK_STORE, { keyPath: "id", autoIncrement: true });
        cs.createIndex("fileId_idx", "fileId", { unique: false });
        cs.createIndex("fileId_index", ["fileId", "index"], { unique: true });
      }
    };
    req.onsuccess = e => { db = e.target.result; resolve(); };
    req.onerror = () => reject(req.error);
  });
}

function addFileMeta(meta) {
  return new Promise((res, rej) => {
    const tx = db.transaction(FILE_STORE, "readwrite");
    const store = tx.objectStore(FILE_STORE);
    const r = store.add(meta);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function addChunkRecord(chunkRec) {
  return new Promise((res, rej) => {
    const tx = db.transaction(CHUNK_STORE, "readwrite");
    const store = tx.objectStore(CHUNK_STORE);
    const r = store.add(chunkRec);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function getAllFiles() {
  return new Promise((res, rej) => {
    const tx = db.transaction(FILE_STORE, "readonly");
    const store = tx.objectStore(FILE_STORE);
    const r = store.getAll();
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function getChunksForFile(fileId) {
  return new Promise((res, rej) => {
    const tx = db.transaction(CHUNK_STORE, "readonly");
    const store = tx.objectStore(CHUNK_STORE);
    const idx = store.index("fileId_index");
    const range = IDBKeyRange.bound([fileId, 0], [fileId, Number.MAX_SAFE_INTEGER]);
    const req = idx.openCursor(range, "next");
    const chunks = [];
    req.onsuccess = e => {
      const cur = e.target.result;
      if (!cur) { res(chunks); return; }
      chunks.push(cur.value);
      cur.continue();
    };
    req.onerror = () => rej(req.error);
  });
}

function deleteFileAndChunks(fileId) {
  return new Promise((res, rej) => {
    const tx = db.transaction([FILE_STORE, CHUNK_STORE], "readwrite");
    tx.objectStore(FILE_STORE).delete(fileId);
    const idx = tx.objectStore(CHUNK_STORE).index("fileId_idx");
    const range = IDBKeyRange.only(fileId);
    const req = idx.openCursor(range);
    req.onsuccess = e => {
      const cur = e.target.result;
      if (!cur) return;
      cur.delete();
      cur.continue();
    };
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}

function clearAllData() {
  return new Promise((res, rej) => {
    const tx = db.transaction([FILE_STORE, CHUNK_STORE], "readwrite");
    tx.objectStore(FILE_STORE).clear();
    tx.objectStore(CHUNK_STORE).clear();
    tx.oncomplete = () => res();
    tx.onerror = () => rej(tx.error);
  });
}

function updateFileChunkCount(fileId, count) {
  return new Promise((res, rej) => {
    const tx = db.transaction(FILE_STORE, "readwrite");
    const store = tx.objectStore(FILE_STORE);
    const r = store.get(fileId);
    r.onsuccess = e => {
      const rec = e.target.result;
      if (!rec) return res();
      rec.chunkCount = count;
      const u = store.put(rec);
      u.onsuccess = () => res();
      u.onerror = () => rej(u.error);
    };
    r.onerror = () => rej(r.error);
  });
}

/* UI wiring */
const fileInput = document.getElementById("fileInput");
const dropZone = document.getElementById("dropZone");
const toggleDrop = document.getElementById("toggleDrop");
const gallery = document.getElementById("gallery");
const clearAllBtn = document.getElementById("clearAll");
const playerModal = document.getElementById("playerModal");
const player = document.getElementById("player");
const playerTitle = document.getElementById("playerTitle");
const status = document.getElementById("status");
const closePlayer = document.getElementById("closePlayer");

toggleDrop.onclick = () => dropZone.style.display = dropZone.style.display === "none" ? "block" : "none";
dropZone.ondragover = e => { e.preventDefault(); dropZone.style.opacity = "0.9"; };
dropZone.ondragleave = e => { dropZone.style.opacity = "1"; };
dropZone.ondrop = e => { e.preventDefault(); dropZone.style.opacity = "1"; handleFiles(e.dataTransfer.files); };

fileInput.onchange = () => handleFiles(fileInput.files);
clearAllBtn.onclick = async () => {
  if (!confirm("Remove all stored videos?")) return;
  await clearAllData();
  await refreshGallery();
};

closePlayer.onclick = () => {
  try {
    const prev = player.dataset.objectUrl;
    if (prev && prev.startsWith("blob:")) URL.revokeObjectURL(prev);
  } catch (e) {}
  try { player.pause(); player.removeAttribute("src"); player.load(); } catch(e){}
  delete player.dataset.objectUrl;
  playerModal.style.display = "none";
  status.textContent = "";
};

/* Quota helper */
async function hasEnoughQuota(fileSize) {
  if (!navigator.storage || !navigator.storage.estimate) return true;
  try {
    const { usage = 0, quota = 0 } = await navigator.storage.estimate();
    const free = Math.max(0, quota - usage);
    return free > fileSize * 1.1; // 10% headroom
  } catch (err) {
    console.warn('quota estimate failed', err);
    return true;
  }
}

/* Chunked upload with progress and cleanup */
async function handleFiles(fileList) {
  if (!fileList || fileList.length === 0) return;
  for (const file of Array.from(fileList)) {
    const total = file.size;
    const expectedChunks = Math.ceil(total / CHUNK_SIZE);
    console.log(`Uploading "${file.name}" size=${total} expectedChunks=${expectedChunks}`);

    const okQuota = await hasEnoughQuota(total);
    if (!okQuota) {
      alert('Not enough browser storage quota to store this file. Try a smaller file or free up space.');
      continue;
    }

    const meta = { name: file.name, size: total, type: file.type || 'video/mp4', createdAt: Date.now(), chunkCount: 0 };
    let fileId;
    try {
      fileId = await addFileMeta(meta);
    } catch (err) {
      console.error('Failed to create file meta', err);
      alert('Failed to create file record. See console.');
      continue;
    }

    // progress UI
    const progressCard = document.createElement('div');
    progressCard.className = 'card';
    progressCard.innerHTML = `<h3>Uploading: ${file.name}</h3>
      <div class="small-muted">0 / ${expectedChunks} chunks</div>
      <div class="progress-wrap"><div class="progress-bar" style="width:0%"></div></div>`;
    gallery.prepend(progressCard);
    const progressText = progressCard.querySelector('.small-muted');
    const progressBar = progressCard.querySelector('.progress-bar');

    let written = 0;
    try {
      for (let index = 0; index < expectedChunks; index++) {
        const start = index * CHUNK_SIZE;
        const end = Math.min(start + CHUNK_SIZE, total);
        const slice = file.slice(start, end);
        await addChunkRecord({ fileId, index, blob: slice });
        written++;
        const pct = Math.round((written / expectedChunks) * 100);
        progressText.textContent = `${written} / ${expectedChunks} chunks`;
        progressBar.style.width = pct + '%';
        await new Promise(r => setTimeout(r, 0)); // yield
      }

      await updateFileChunkCount(fileId, expectedChunks);
      console.log(`Upload complete for fileId ${fileId}`);
    } catch (err) {
      console.error('Chunk write failed', err);
      try { await deleteFileAndChunks(fileId); } catch (e) { console.warn('cleanup failed', e); }
      alert('Upload failed (see console). Partial data removed.');
    } finally {
      setTimeout(() => { progressCard.remove(); refreshGallery(); }, 800);
    }
  }
  fileInput.value = '';
}

/* Playback using object URL (assemble chunks into Blob) */
async function playWithObjectURL(fileRec) {
  status.textContent = "Assembling blob for playback...";
  const chunks = await getChunksForFile(fileRec.id);
  if (!chunks || chunks.length === 0) { status.textContent = "No chunks found."; return; }

  // sort by index to ensure correct order
  chunks.sort((a, b) => a.index - b.index);

  // create a single Blob from chunk blobs
  const blob = new Blob(chunks.map(c => c.blob), { type: fileRec.type || 'video/mp4' });
  const url = URL.createObjectURL(blob);

  // revoke previous object URL if any
  try {
    const prev = player.dataset.objectUrl;
    if (prev && prev.startsWith('blob:')) URL.revokeObjectURL(prev);
  } catch (e) {}

  player.src = url;
  player.dataset.objectUrl = url;
  playerModal.style.display = "flex";
  playerTitle.textContent = fileRec.name;
  status.textContent = "Playing via object URL. Close to release memory.";
  player.play().catch(()=>{});
}

/* Gallery rendering */
async function refreshGallery() {
  const files = await getAllFiles();
  gallery.innerHTML = "";
  if (!files.length) {
    gallery.innerHTML = "<p style='color:#bbb'>No videos stored yet.</p>";
    return;
  }
  files.sort((a, b) => b.createdAt - a.createdAt);
  for (const f of files) {
    const card = document.createElement("div");
    card.className = "card";
    const title = document.createElement("h3");
    title.textContent = f.name;
    card.appendChild(title);

    const meta = document.createElement("div");
    meta.className = "meta";
    const info = document.createElement("div");
    const sizeMB = (f.size / 1024 / 1024).toFixed(2);
    info.textContent = `${sizeMB} MB • ${f.chunkCount || 0} chunks`;

    const actions = document.createElement("div");
    const playBtn = document.createElement("button");
    playBtn.className = "small-btn";
    playBtn.textContent = "Play";
    playBtn.onclick = async () => {
      status.textContent = "";
      try {
        await playWithObjectURL(f);
      } catch (err) {
        console.error("play err", err);
        alert("Playback failed. See console.");
      }
    };

    const downloadBtn = document.createElement("button");
    downloadBtn.className = "small-btn";
    downloadBtn.style.marginLeft = "0.5rem";
    downloadBtn.textContent = "Download";
    downloadBtn.onclick = async () => {
      const chunks = await getChunksForFile(f.id);
      const blob = new Blob(chunks.map(c => c.blob), { type: f.type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = f.name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    };

    const delBtn = document.createElement("button");
    delBtn.className = "small-btn";
    delBtn.style.marginLeft = "0.5rem";
    delBtn.textContent = "Delete";
    delBtn.onclick = async () => {
      if (!confirm("Delete this stored video?")) return;
      await deleteFileAndChunks(f.id);
      await refreshGallery();
    };

    actions.appendChild(playBtn);
    actions.appendChild(downloadBtn);
    actions.appendChild(delBtn);

    meta.appendChild(info);
    meta.appendChild(actions);
    card.appendChild(meta);
    gallery.appendChild(card);
  }
}

/* Init */
(async function init() {
  try {
    await openDB();
    await refreshGallery();
  } catch (err) {
    console.error("DB init failed:", err);
    alert("Failed to open IndexedDB. Make sure your browser supports it and storage is available.");
  }
})();
</script>
</body>
<p>
  All you need to do is get a video paste it on here then delete it from you pc then boom inf storage
</p>
<footer>
  &copy; Zakai's Code 2025 By the way if you 
</footer>
</html>
