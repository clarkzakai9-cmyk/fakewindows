<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Chunked HTML Library</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:Segoe UI,Roboto,system-ui;background:#0f0f0f;color:#fff;padding:2rem}
  .controls{display:flex;gap:.5rem;flex-wrap:wrap;margin-bottom:1rem}
  input[type=file]{padding:.5rem;border-radius:8px;background:#111;color:#fff;border:1px solid #222}
  button{background:#ff4b2b;color:#fff;border:none;padding:.5rem .8rem;border-radius:8px;cursor:pointer}
  .card{background:#1e1e1e;padding:1rem;border-radius:10px;margin-bottom:.75rem}
  iframe{width:100%;height:60vh;border:1px solid #222;border-radius:8px;background:#fff}
  .meta{display:flex;justify-content:space-between;align-items:center;gap:.5rem;color:#bbb}
</style>
</head>
<body>
  <h1>Chunked HTML Library</h1>
  <div class="controls">
    <input id="fileInput" type="file" accept=".html,text/html" />
    <button id="clearAll">Clear All</button>
  </div>

  <div id="gallery"></div>

  <div id="previewModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.7);align-items:center;justify-content:center;z-index:999">
    <div style="background:#111;padding:1rem;border-radius:10px;width:90%;max-width:1000px">
      <button id="closePreview" style="float:right">Close</button>
      <h3 id="previewTitle"></h3>
      <label style="color:#bbb">Iframe sandbox</label>
      <select id="sandboxSelect">
        <option value="allow-scripts">allow-scripts</option>
        <option value="allow-scripts allow-same-origin">allow-scripts allow-same-origin</option>
        <option value="">strict sandbox</option>
      </select>
      <div style="margin-top:.5rem"><iframe id="previewFrame" sandbox="allow-scripts"></iframe></div>
    </div>
  </div>

<script>
const CHUNK_SIZE = 64 * 1024 * 1024;
const DB_NAME = 'chunkedHtmlDB';
const FILE_STORE = 'files';
const CHUNK_STORE = 'chunks';
let db;

function openDB(){
  return new Promise((res, rej) => {
    const r = indexedDB.open(DB_NAME, 1);
    r.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains(FILE_STORE)) d.createObjectStore(FILE_STORE, { keyPath:'id', autoIncrement:true });
      if (!d.objectStoreNames.contains(CHUNK_STORE)) {
        const cs = d.createObjectStore(CHUNK_STORE, { keyPath:'id', autoIncrement:true });
        cs.createIndex('fileId_index', ['fileId','index'], { unique:true });
        cs.createIndex('fileId_idx', 'fileId', { unique:false });
      }
    };
    r.onsuccess = e => { db = e.target.result; res(); };
    r.onerror = () => rej(r.error);
  });
}

function addFileMeta(meta){ return new Promise((res,rej)=>{ const tx=db.transaction(FILE_STORE,'readwrite'); const s=tx.objectStore(FILE_STORE); const r=s.add(meta); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
function addChunk(chunk){ return new Promise((res,rej)=>{ const tx=db.transaction(CHUNK_STORE,'readwrite'); const s=tx.objectStore(CHUNK_STORE); const r=s.add(chunk); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
function getAllFiles(){ return new Promise((res,rej)=>{ const tx=db.transaction(FILE_STORE,'readonly'); const s=tx.objectStore(FILE_STORE); const r=s.getAll(); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
function getChunksForFile(fileId){ return new Promise((res,rej)=>{ const tx=db.transaction(CHUNK_STORE,'readonly'); const s=tx.objectStore(CHUNK_STORE); const idx=s.index('fileId_index'); const range=IDBKeyRange.bound([fileId,0],[fileId,Number.MAX_SAFE_INTEGER]); const req=idx.openCursor(range); const out=[]; req.onsuccess=e=>{ const cur=e.target.result; if(!cur){ res(out); return; } out.push(cur.value); cur.continue(); }; req.onerror=()=>rej(req.error); }); }
function deleteFileAndChunks(fileId){ return new Promise((res,rej)=>{ const tx=db.transaction([FILE_STORE,CHUNK_STORE],'readwrite'); tx.objectStore(FILE_STORE).delete(fileId); const idx=tx.objectStore(CHUNK_STORE).index('fileId_idx'); const range=IDBKeyRange.only(fileId); const req=idx.openCursor(range); req.onsuccess=e=>{ const cur=e.target.result; if(!cur) return; cur.delete(); cur.continue(); }; tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
function clearAll(){ return new Promise((res,rej)=>{ const tx=db.transaction([FILE_STORE,CHUNK_STORE],'readwrite'); tx.objectStore(FILE_STORE).clear(); tx.objectStore(CHUNK_STORE).clear(); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }

async function handleFile(file){
  const total = file.size;
  const expected = Math.ceil(total/CHUNK_SIZE);
  const meta = { name:file.name, size:total, type:file.type||'text/html', createdAt:Date.now(), chunkCount:0 };
  const fileId = await addFileMeta(meta);
  for(let i=0;i<expected;i++){
    const start=i*CHUNK_SIZE, end=Math.min(start+CHUNK_SIZE,total);
    const slice = file.slice(start,end);
    await addChunk({ fileId, index:i, blob:slice });
  }
  // update chunkCount
  const tx = db.transaction(FILE_STORE,'readwrite'); const s = tx.objectStore(FILE_STORE);
  const r = s.get(fileId);
  r.onsuccess = e => { const rec = e.target.result; rec.chunkCount = expected; s.put(rec); refreshGallery(); };
}

async function refreshGallery(){
  const files = await getAllFiles();
  const gallery = document.getElementById('gallery');
  gallery.innerHTML = '';
  if(!files.length){ gallery.innerHTML = '<p style="color:#bbb">No HTML files stored.</p>'; return; }
  files.sort((a,b)=>b.createdAt-a.createdAt);
  for(const f of files){
    const card = document.createElement('div'); card.className='card';
    card.innerHTML = `<strong>${f.name}</strong><div class="meta">${(f.size/1024/1024).toFixed(2)} MB â€¢ ${f.chunkCount||0} chunks
      <span></span></div>`;
    const actions = document.createElement('div'); actions.style.marginTop='.5rem';
    const preview = document.createElement('button'); preview.textContent='Preview';
    preview.onclick = async ()=>{
      const chunks = await getChunksForFile(f.id);
      chunks.sort((a,b)=>a.index-b.index);
      const blob = new Blob(chunks.map(c=>c.blob), { type: f.type });
      const url = URL.createObjectURL(blob);
      document.getElementById('previewFrame').src = url;
      document.getElementById('previewTitle').textContent = f.name;
      document.getElementById('previewModal').style.display='flex';
      document.getElementById('previewFrame').dataset.objectUrl = url;
    };
    const download = document.createElement('button'); download.textContent='Download';
    download.onclick = async ()=>{
      const chunks = await getChunksForFile(f.id);
      const blob = new Blob(chunks.map(c=>c.blob), { type: f.type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download=f.name; document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url),2000);
    };
    const del = document.createElement('button'); del.textContent='Delete';
    del.onclick = async ()=>{ if(!confirm('Delete this file?')) return; await deleteFileAndChunks(f.id); refreshGallery(); };
    actions.appendChild(preview); actions.appendChild(download); actions.appendChild(del);
    card.appendChild(actions);
    gallery.appendChild(card);
  }
}

document.getElementById('fileInput').onchange = e => {
  const f = e.target.files[0]; if(!f) return; if(!f.name.endsWith('.html')) { if(!confirm('File is not .html. Continue?')) return; }
  handleFile(f).catch(err=>{ console.error(err); alert('Upload failed'); });
  e.target.value='';
};

document.getElementById('clearAll').onclick = async ()=>{ if(!confirm('Clear all stored HTML?')) return; await clearAll(); refreshGallery(); };

document.getElementById('closePreview').onclick = ()=>{
  const frame = document.getElementById('previewFrame');
  try{ const prev = frame.dataset.objectUrl; if(prev && prev.startsWith('blob:')) URL.revokeObjectURL(prev); }catch(e){}
  frame.removeAttribute('src'); document.getElementById('previewModal').style.display='none';
};

document.getElementById('sandboxSelect').onchange = function(){
  document.getElementById('previewFrame').setAttribute('sandbox', this.value);
};

(async function init(){ await openDB(); await refreshGallery(); })();
</script>
</body>
</html>
